{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/index.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","__assign","this","Object","assign","arguments","p","prototype","hasOwnProperty","defineProperty","value","Rx","window","global","Immutable","BehaviorSubject","Subject","ReducerTypes","createStore","initialState","initialReducers","initialEffects","initialMiddleware","initialExtras","mergedInitialState","alwaysMap","state$","userExtra$","newExtras$","scan","extras","incoming","subscribe","action$","storeReducers","newReducer$","acc","concat","mappedReducers","newMappedReducer$","storeResponses","newResponses","stateUpdate$","do","action","isPlainObject","console","error","type","withLatestFrom","reducers","mappedReducersThatMatchAction","filter","reducer","name","stateMap","_a","actionType","indexOf","setIn","payload","path","reduce","outgoingValue","reducerPayload","MappedReducer","updateIn","currentValue","fns","fn","share","catch","err","Observable","throw","actionsWithState$","state","storeExtras","actionsWithResultingStateUpdate$","_","flatMap","actionName","matchingResponses","response","newActions","map","x","targetName","getIn","getMap","toJS","via","from","_dispatcher","Array","isArray","forEach","onNext","_addReducers","alwaysArray","Boolean","keys","stateKey","effects","_addEffects","_registerOnStateTree","currentFn","key","actionsApi","ofType","getValue","effect","stream","triggers","trigger","_addMiddleware","middleware","api","_addExtras","extra","_addResponses","responses","resp","item","register","input","addReducers","dispatch","getState","lookup","toJSON","addMiddleware","once","actions","take","changes","distinctUntilChanged","Map","isMap","fromJS","objectTag","toString","default","staunch"],"mappings":"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","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Rx = (typeof window !== \"undefined\" ? window['Rx'] : typeof global !== \"undefined\" ? global['Rx'] : null);\nvar Immutable = (typeof window !== \"undefined\" ? window['Immutable'] : typeof global !== \"undefined\" ? global['Immutable'] : null);\nvar BehaviorSubject = Rx.BehaviorSubject;\nvar Subject = Rx.Subject;\nvar ReducerTypes;\n(function (ReducerTypes) {\n    ReducerTypes[ReducerTypes[\"MappedReducer\"] = 'MappedReducer'] = \"MappedReducer\";\n    ReducerTypes[ReducerTypes[\"GlobalReducer\"] = 'GlobalReducer'] = \"GlobalReducer\";\n})(ReducerTypes = exports.ReducerTypes || (exports.ReducerTypes = {}));\nfunction createStore(initialState, initialReducers, initialEffects, initialMiddleware, initialExtras) {\n    var mergedInitialState = alwaysMap(initialState);\n    var state$ = new BehaviorSubject(mergedInitialState);\n    var userExtra$ = new BehaviorSubject({});\n    var newExtras$ = new Subject();\n    newExtras$.scan(function (extras, incoming) {\n        return Object.assign({}, extras, incoming);\n    }, {}).subscribe(userExtra$);\n    // stream of actions\n    var action$ = new Subject();\n    // reducers to act upon state\n    var storeReducers = new BehaviorSubject([]);\n    var newReducer$ = new Subject();\n    newReducer$.scan(function (acc, incoming) {\n        return acc.concat(incoming);\n    }, []).subscribe(storeReducers);\n    // Mapped reducers\n    var mappedReducers = new BehaviorSubject([]);\n    var newMappedReducer$ = new Subject();\n    newMappedReducer$.scan(function (acc, incoming) {\n        return acc.concat(incoming);\n    }, []).subscribe(mappedReducers);\n    // responses\n    var storeResponses = new BehaviorSubject([]);\n    var newResponses = new Subject();\n    newResponses.scan(function (acc, incoming) {\n        return acc.concat(incoming);\n    }, []).subscribe(storeResponses);\n    // stream\n    var stateUpdate$ = action$\n        .do(function (action) {\n        if (!isPlainObject(action)) {\n            return console.error('Please provide an object with at least a `type` property');\n        }\n        if ((typeof action.type) !== 'string') {\n            return console.error('Action was missing a `type` property', action);\n        }\n    })\n        .withLatestFrom(storeReducers, mappedReducers, function (action, reducers, mappedReducers) {\n        var mappedReducersThatMatchAction = mappedReducers\n            .filter(function (reducer) {\n            return reducer.name === action.type;\n        });\n        return {\n            action: action,\n            reducers: mappedReducersThatMatchAction.concat(reducers),\n        };\n    })\n        .scan(function (stateMap, _a) {\n        var action = _a.action, reducers = _a.reducers;\n        var actionType = action.type || (typeof action === 'string' ? action : '');\n        // is it a @@namespace ?\n        if (actionType.indexOf('@@NS-INIT') === 0) {\n            return stateMap.setIn(action.payload.path, alwaysMap((action.payload || {}).value));\n        }\n        else {\n            /**\n             * Iterate through all valid reducers\n             * This will include those registered via simple functions\n             * + those mapped to a path with a specific Action name\n             */\n            return reducers.reduce(function (outgoingValue, reducer) {\n                /**\n                 * Decide whether to pass {type: NAME, payload: VALUE}\n                 *                   or   VALUE only into the reducer\n                 *\n                 */\n                var reducerPayload = reducer.type === ReducerTypes.MappedReducer\n                    ? action.payload\n                    : action;\n                /**\n                 * Now use updateIn to call this reducers functions (there could be many)\n                 * on the value that lives at this point of the tree\n                 */\n                return outgoingValue.updateIn(reducer.path, function (currentValue) {\n                    return reducer.fns.reduce(function (value, fn) {\n                        return fn.call(null, value, reducerPayload, outgoingValue);\n                    }, currentValue);\n                });\n            }, stateMap);\n        }\n    }, mergedInitialState).share();\n    // Push all state updates back onto state$ value\n    stateUpdate$\n        .catch(function (err) {\n        // console.error(err);\n        return Rx.Observable.throw(err);\n    })\n        .subscribe(state$);\n    /**\n     * Create a stream that has updates + resulting state updates\n     */\n    var actionsWithState$ = action$.withLatestFrom(state$, function (action, state) {\n        return {\n            action: action,\n            state: state\n        };\n    });\n    var storeExtras = {\n        state$: state$,\n        action$: action$,\n        actionsWithState$: actionsWithState$,\n        actionsWithResultingStateUpdate$: actionsWithState$\n    };\n    /**\n     * Setup responses for declarative cross-domain communication\n     */\n    actionsWithState$\n        .withLatestFrom(storeResponses)\n        .filter(function (_a) {\n        var _ = _a[0], storeResponses = _a[1];\n        return storeResponses.length > 0;\n    })\n        .flatMap(function (incoming) {\n        var _a = incoming[0], action = _a.action, state = _a.state;\n        var storeResponses = incoming[1];\n        var actionName = action.type;\n        var matchingResponses = storeResponses\n            .filter(function (response) { return response.name === actionName; });\n        var newActions = matchingResponses.map(function (x) {\n            return {\n                type: x.targetName,\n                payload: state.getIn(x.path, getMap({})).toJS(),\n                via: \"[response to (\" + actionName + \")]\"\n            };\n        });\n        return Rx.Observable.from(newActions);\n    })\n        .subscribe(function (action) { return _dispatcher(action); });\n    /**\n     * Dispatch 1 or many actions\n     * @param action\n     * @returns {*}\n     * @private\n     */\n    function _dispatcher(action) {\n        if (Array.isArray(action)) {\n            return action.forEach(function (a) {\n                action$.onNext(a);\n            });\n        }\n        return action$.onNext(action);\n    }\n    /**\n     * Add either plain functions or {path, fns} pairs\n     * @param reducers\n     * @private\n     */\n    function _addReducers(reducers) {\n        alwaysArray(reducers).forEach(function (reducer) {\n            if (typeof reducer === 'function') {\n                newReducer$.onNext({\n                    path: [],\n                    fns: [].concat(reducer).filter(Boolean)\n                });\n            }\n            if (isPlainObject(reducer)) {\n                if (reducer.state) {\n                    if (reducer.reducers) {\n                        /**\n                         * if 'state' and 'reducers' key were found,\n                         * we bind the reducers to that top-level state key\n                         */\n                        Object.keys(reducer.state).forEach(function (stateKey) {\n                            _addReducers({ path: stateKey, fns: reducer.reducers });\n                        });\n                    }\n                    if (reducer.effects) {\n                        _addEffects(reducer.effects);\n                    }\n                    /**\n                     *\n                     */\n                    _registerOnStateTree(reducer.state);\n                    return;\n                }\n                if (reducer.path && reducer.reducers) {\n                    Object.keys(reducer.reducers).forEach(function (name) {\n                        var currentFn = reducer.reducers[name];\n                        newMappedReducer$.onNext({\n                            path: [].concat(reducer.path),\n                            fns: [currentFn],\n                            name: name,\n                            type: ReducerTypes.MappedReducer\n                        });\n                    });\n                    return;\n                }\n                /**\n                 * if path/fn pairs given\n                 */\n                if (reducer.path && reducer.fns) {\n                    newReducer$.onNext({\n                        path: [].concat(reducer.path).filter(Boolean),\n                        fns: [].concat(reducer.fns).filter(Boolean)\n                    });\n                }\n                else {\n                    // redux style key: fn pairs\n                    for (var key in reducer) {\n                        newReducer$.onNext({\n                            path: [].concat(key).filter(Boolean),\n                            fns: [].concat(reducer[key]).filter(Boolean)\n                        });\n                    }\n                }\n            }\n        });\n    }\n    function _addEffects(effects) {\n        var actionsApi = {\n            ofType: function (actionName) {\n                return actionsWithState$.filter(function (incoming) {\n                    return incoming.action.type === actionName;\n                });\n            }\n        };\n        var extras = Object.assign({}, storeExtras, userExtra$.getValue());\n        alwaysArray(effects).forEach(function (effect) {\n            if (typeof effect !== 'function') {\n                console.error('Effects must be functions, you provided', effect);\n            }\n            var stream = (function () {\n                if (effect.triggers && Array.isArray(effect.triggers)) {\n                    return actionsWithState$.filter(function (incoming) {\n                        return ~effect.triggers.indexOf(incoming.action.type);\n                    });\n                }\n                if (effect.trigger && typeof effect.trigger === 'string') {\n                    return actionsWithState$.filter(function (incoming) {\n                        return effect.trigger === incoming.action.type;\n                    });\n                }\n                return actionsApi;\n            })();\n            effect.call(null, stream, extras)\n                .map(function (action) {\n                return __assign({}, action, { via: '[effect]', name: (effect.name || '') });\n            })\n                .forEach(function (action) {\n                _dispatcher(action);\n            });\n        });\n    }\n    function _addMiddleware(middleware) {\n        alwaysArray(middleware).forEach(function (middleware) {\n            middleware.call(null, api);\n        });\n    }\n    function _addExtras(extras) {\n        alwaysArray(extras).forEach(function (extra) {\n            newExtras$.onNext(extra);\n        });\n    }\n    function _registerOnStateTree(state) {\n        for (var key in state) {\n            // now init with action\n            _dispatcher({\n                type: '@@NS-INIT(' + key + ')',\n                payload: {\n                    path: [key],\n                    value: state[key]\n                }\n            });\n        }\n    }\n    function _addResponses(responses) {\n        alwaysArray(responses).forEach(function (resp) {\n            Object.keys(resp).forEach(function (actionName) {\n                var item = resp[actionName];\n                newResponses.onNext({\n                    name: actionName,\n                    path: [].concat(item.path).filter(Boolean),\n                    targetName: item.action\n                });\n            });\n        });\n    }\n    var api = {\n        state$: state$,\n        action$: action$,\n        actionsWithState$: actionsWithState$,\n        actionsWithResultingStateUpdate$: actionsWithState$,\n        register: function (input) {\n            var state = input.state, reducers = input.reducers, effects = input.effects, responses = input.responses;\n            if (state) {\n                _registerOnStateTree(state);\n            }\n            if (reducers) {\n                _addReducers(reducers);\n            }\n            if (effects) {\n                _addEffects(effects);\n            }\n            if (responses) {\n                _addResponses(responses);\n            }\n            return api;\n        },\n        addReducers: function (reducers) {\n            _addReducers(reducers);\n            return api;\n        },\n        dispatch: function (action) {\n            _dispatcher(action);\n            return api;\n        },\n        getState: function (path) {\n            var lookup = alwaysArray(path);\n            return state$.getValue().getIn(lookup, getMap({}));\n        },\n        toJS: function (path) {\n            var lookup = alwaysArray(path);\n            return state$.getValue().getIn(lookup, getMap({})).toJS();\n        },\n        toJSON: function (path) {\n            var lookup = alwaysArray(path);\n            return state$.getValue().getIn(lookup, getMap({})).toJSON();\n        },\n        addMiddleware: function (middleware) {\n            _addMiddleware(middleware);\n            return api;\n        },\n        once: function (actions) {\n            var lookup = alwaysArray(actions);\n            return actionsWithState$.filter(function (x) {\n                return lookup.indexOf(x.action.type) > -1;\n            }).take(1);\n        },\n        changes: function (path) {\n            var lookup = alwaysArray(path);\n            return state$.map(function (x) { return x.getIn(lookup); })\n                .distinctUntilChanged();\n        }\n    };\n    // add initial ones\n    _addReducers(initialReducers);\n    _addEffects(initialEffects);\n    _addMiddleware(initialMiddleware);\n    _addExtras(initialExtras);\n    function alwaysMap(input) {\n        return Immutable.Map.isMap(input) ? input : Immutable.fromJS(input || {});\n    }\n    function alwaysArray(input) {\n        return [].concat(input).filter(Boolean);\n    }\n    function isPlainObject(value) {\n        var objectTag = '[object Object]';\n        return Object.prototype.toString.call(value) === objectTag;\n    }\n    function getMap(incoming) {\n        return Immutable.Map(incoming);\n    }\n    return api;\n}\nexports.createStore = createStore;\nexports.default = createStore;\nif (window && ((typeof window.staunch) === 'undefined')) {\n    window.staunch = {\n        createStore: createStore\n    };\n}\n//# sourceMappingURL=index.js.map"]}